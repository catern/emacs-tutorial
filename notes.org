#+TITLE: Emacs Fundamentals
* TODO Scraps
** Fun ideas
   Note: I can easily come up with fun ideas for the elisp hacking part, it's the documentation and terminology part that is more difficult.
*** Typing in name while holding down Ctrl
    Then use lossage to see it
    Then use C-h k to see what the first few do
    Then use kmacro-edit-lossage to see what it all does.
*** Games?
    Just play games?
** Other stuff
Add C-y for redo in cua-mode... except cua-mode isn't really necessary anyway...
GUI mode in OS X has CMD-v shortcuts etc. enabled
Counter-CUA:GUI on OS X is already using Mac-CUA, GUI on Windows won't work remotely since no SSH, so people will need to learn anyway.
So: On OS X and Linux, you should install the GUI. On Linux, you might want to use cua-mode I suppose.
On Windows, the GUI won't work remotely because no ssh, so try X forwarding Emacs instead I guess if you want to use cua.

So since OS X has no need for cua-mode, and Windows won't work graphically and CUA doesn't work as well non-graphically...
I guess I'll just mention cua-mode rather than enable it.
** Consider tabbar-mode
   It is pretty slick and people might find it familiar.
* Salespitch
  One can praise vim all they want,
  but even the fiercest proponent must admit:
  vim's claims to greatness are controversial.
  I should know, I used vim for years, and I've become an expert.
  Besides its interesting keybindings, it doesn't have a clear case for superiority.
  
  On the other hand, 
  there is an program that, in several ways, is uncontroversially the world's best.
  It has the best help system of any application ever.
  It is the best portable environment for Lisp hacking.
  It is the world's most live-hackable and extensible system.
  These are not controversial statements. They can be generally agreed on by everyone.
  
  I am describing Emacs,
  and if you're interested,
  come to my workshop,
  and you can learn the more controversial truth:
  It is also the world's best text editor.
* TODO Introduction
  What you learn this day will forever serve as your firm foundation in the arts of Emacs, 
  no matter who your teachers before and after.
  
  I will teach you how to act on your own in Emacs.
  You will not need to be dependent on gurus or wisemen or shamans,
  but will be able to harness Emacs purely through your own fingers and strength of will.
* TODO Getting started
  Some preliminary knowledge to make things work nicely.
** =Ctrl-g=
   This is your universal panic key.
   It interrupts whatever is happening and gets you back to a familiar state.
   It's the equivalent of Ctrl-c, for Emacs.
   If at first it doesn't seem to work, hit it some more!
** Emacs tutorial
   Do it!
   
   To enter the Emacs tutorial from the command line, enter
#+begin_src sh
emacs -f help-with-tutorial
#+end_src

   To enter the Emacs tutorial while already inside Emacs, press "F1", then "t".
   (If you don't have an "F1" key, you can press "C-h" instead, then "t")

*** Non-English
   If English is not your native language, do this instead from the command line:
#+begin_src sh
emacs --eval '(help-with-tutorial t)'
#+end_src
   Or =C-u C-h t= inside Emacs.
   In either case, then type your preferred option and press Enter.

** Terminology
   Emacs uses a small amount of unique terminology.
   This is all mostly described in the Emacs tutorial,
   and also in the Emacs glossary in the Emacs manual.
   (which, as you will learn later in this document,
   is one of the best manuals ever written)

*** Keybinding notation
    A "keybinding" is some keyboard input bound to perform some command.
    For example, =C-a= goes to the beginning of the line.
    Emacs uses a specialized notation for denoting keyboard commands.

    - =C-h= for Ctrl-h.
      That is, hold down the Control key, press h, then release the Control key.
    - =M-f= for Alt-f.
      Alt is historically known as the Meta key, so M stands for Meta.
    - =C-x C-s= for Ctrl-x then immediately Ctrl-s.
      You don't need to release the Control key in between.
    - =C-x s= for Ctrl-x then immediately just s
    - =C-h K= for Ctrl-h, then immediately just K. That is, upper-case K, entered as normal with shift.
    - =RET= for Return/Enter
    - =SPC= for Space
    - =DEL= for Backspace
      
    A chain of keys pressed in sequence to have a single effect, like =C-x C-s=, is known as a "key chord".
    Often "key chord" is also used to refer to a single keypress, like =C-a=.
    Note that a keybinding in Emacs is simply a mapping from a keychord of one or more keys,
    to some named function (as in "function call") written in the programming language underlying Emacs.
    For example, =C-a= maps to =beginning-of-line=.
    Later, in the documentation section, you'll learn a number of ways to reveal this mapping.
*** Buffers
    When you open a file, its text appears in a buffer, and you can edit it.
    Each buffer has a name, which is usually the name of the file.
    You can also create buffers that aren't associated with files, and save them (specifying a filename) to create a new file.
    You can create a new buffer by switching to a buffer with a name that isn't already used.
    
*** Frames
    Each instance of Emacs on a terminal, and each graphical instance, is a frame.
    (In the context of a graphical environment, this would be called a "window";
    but that word doesn't make much sense in a terminal...)
    An Emacs process can have multiple frames, both terminal and graphical, which can be opened and closed independently.
    Frames contain one or more windows in some arrangement.
    
*** Windows
    A window contains exactly one buffer. 
    A window is itself contained in a frame, possibly along with other windows arranged in some layout.
    There can be multiple windows showing the same buffer, sometimes at different points in the buffer;
    this is useful if you want to get multiple views into a large file.
    Indeed, there can be multiple frames showing the same buffer, all supporting simultaneous editing...
*** Point
    The position of the text cursor; where new text will be inserted if you type.
*** Modes, major and minor
    For any buffer, there is exactly one major mode, and any number of minor modes.

    The major mode determines the primary purpose and functionality of the buffer.
    A buffer for editing C code would have c-mode as its major mode,
    and a buffer for editing Python code would have python-mode.
    Those modes provide syntax highlighting and customize the keybindings to more suited for the specific language.
    When you open a file ending in ".c" or ".py", Emacs automatically runs the appropriate mode.
    Other major modes exist and provide other more arcane functionality.
    
    Minor modes generally provide less significant functionality,
    and there can be any number of them active in a buffer.
    Some minor modes are called "global", and can be turned on or off for all buffers at once.
    
    One can enter a major or minor mode in the same way one can enter any other Emacs command:
    with =M-x name-of-mode=
    Line numbers, for example, can be turned on for the current buffer by running =M-x linum-mode=,
    or for all buffers with =M-x global-linum-mode=. (But I don't recommend it...)
*** Minibuffer
    The line at the very bottom of the screen 
    where brief messages and prompts for input are displayed.
*** Modeline
    Just above the minibuffer,
    displays the name of the current buffer,
    the percentage position in the document,
    the line number that point is at,
    the currently active modes in short-form,
    and occassionally other helpful information.

    Mouse over it in graphical Emacs to see tool-tips describing what everything is.
** Running Emacs
   Here are a few tips about how best to run Emacs. 
   Just running =emacs= while SSH'd into unix.andrew.cmu.edu is fine, 
   but you can make things easier for yourself if you try these methods...
*** Installing Emacs
    You should install Emacs locally on your personal computer (though you can still use it remotely if you must).
    This has a number of benefits, including 
    giving you the ability to use the GUI version of Emacs (and the mouse!),
    working remotely with the integrated remote access functionality known as TRAMP,
    being able to experiment more with Emacs features,
    and getting access to the latest version of Emacs with the latest advancements.
    
    You can check your Emacs version by running "emacs --version" in a shell, 
    or running "M-x version" from inside Emacs.

**** Linux
      Use your package manager. :)
      (But do make sure you have a recent version, since your distro might be out of date...)
**** OS X
     Apple ships an ancient version of Emacs and doesn't include the GUI version.
     Update your version of Emacs on OS X by downloading an installer from [[http://emacsformacosx.com/][here]].
     Or, if you have Homebrew installed, run
#+begin_src sh
brew install emacs --cocoa
#+end_src

     To run the terminal version, you'll need to find the Emacs binary and add it to your PATH.
     I don't know how to do this with Homebrew, but for the installer I linked above, there are instructions [[http://emacsformacosx.com/tips][here]].
**** Windows
      Emacs is surprisingly well supported on Windows - way better than vim is.
      Check out [[http://www.gnu.org/software/emacs/manual/html_node/efaq-w32/index.html][this FAQ on Emacs for Windows]], or just go [[http://www.gnu.org/software/emacs/manual/html_node/efaq-w32/Downloading.html#Downloading][directly to the download]].
*** Emacs in GUI mode
    It's better to use GUI Emacs rather than terminal Emacs.
    GUI Emacs comes with buttons! 
    And you can use your mouse!
    And it's prettier!
    And even for people who never use the mouse (like me) it is better than terminal Emacs.

    But if you must use Emacs in the terminal, 
    read my article on the various quirks and limitations of the terminal environment: 
    http://catern.com/posts/terminal_quirks.html
    (If you wonder why using GUI Emacs is better than terminal Emacs for keyboard users, that article explains why.)
*** Emacs as a daemon
    Emacs can run as a daemon, a process running in the background without necessarily displaying any graphical or terminal interface.
    You can start the Emacs daemon by running the following command in your shell:
#+begin_src sh
emacs --daemon
#+end_src

    Running =M-x server-start= inside an already running Emacs will also let you experiment with the =emacsclient= command described below,
    but the Emacs daemon (also known as the Emacs server) will exit when you close the original Emacs.
    If you start it from the command line, it will stay running even if you don't have Emacs open.
    
    Why is this helpful?
    Well, if you came to a previous talk about tmux, this is useful for some of the same reasons.
    If you have some set of files open or some valuable data entered but not saved,
    both =emacs --daemon= and =tmux= will keep that safe even if you disconnect.

    The difference is, =emacs --daemon= is *automatic*.
    Once you run it, if you switch to using =emacsclient -c=,
    everything you do inside Emacs will automatically become immune to disconnections or you closing your terminal.
    You don't have to start new windows inside =tmux= to perform new tasks; you just use Emacs as normal.
    
    And there are other advantages that are unique to =emacs --daemon=.
    For one, you can freely switch between terminal Emacs and graphical Emacs, sharing all your open buffers.
    
    Another power that's unique to =emacs --daemon= is its smart behavior when you have multiple terminals open.
    Say you log in from one place and open a file, and perform some edits.
    You leave that login running; maybe you just forget that that terminal is open.
    Now you login from a new terminal, and you want to open the same file to get some work done.
    But if you opened it twice and edited it twice, you might cause conflicts and great pain for yourself!

    In lesser editors, this means you're out of luck.
    A lesser editor can tell that another instance of itself is editing the file, but that's all it can do,
    so it will be cautious and refuse to open the file twice - you'll have to hunt down your original login and use that one.

    But if you're running =emacsclient -c= to open that file, then the best possible thing that could happen, does happen:
    Emacs opens normally, and the buffer for that file is shared between the two open Emacs frames;
    any of your existing edits show up in the new Emacs.[fn:whyiswitched]

    In fact, you can use this buffer-sharing capability of Emacs for collaborative editing!
    I quite frequently collborate with colleagues by having us both connect to a shared Emacs daemon,
    and edit the same buffer at the same time.
    
    I'm of the opinion that every application should have this amazing functionality.
    Sadly, only Emacs is advanced enough to have it.
    Maybe someday the rest of the world will catch up.
*** The Ctrl key
    It's very useful to remap CapsLock to Ctrl.
    CapsLock is a useless key, and Ctrl is a very useful one, 
    so it's good to make Control easier to hit while touch typing.
    You can follow this guide: http://emacswiki.org/emacs/MovingTheCtrlKey
    (This is of course still helpful even if you don't use Emacs.)
** TODO Bare essentials of configuration
   Later in this document I will explain configuration in detail,
   after the sections on documentation and basic usage.
   But to set the foundations for that section,
   it would be useful for you to have a simple configuration already in place.
   And if I'm going to give you a simple configuration anyway,
   you might as well get the advantage of using it through the documentation and usage sections as well.

   I hate to tell you to do something without explaining it, but that's useful in this case.
   So, for the only time in this document, please follow these instructions blindly to put the simple example configuration in place.
   
   If you will use Emacs both remotely and on your local computer,
   pick the appropriate two branches.
   (Note that all these branches give you the exact same configuration.)

*** Emacs installed on =unix.andrew.cmu.edu= (or any remote Linux machine)
    Open a new terminal. Log in to the remote server in question as normal. 
    Copy and paste the following:

*** Emacs installed on your local Linux/OS X machine

#+begin_src sh
mkdir -p ~/.emacs.d/ && curl 
#+end_src

*** Emacs installed on your local Windows machine
    Open Emacs and type the following (if you don't understand what =C-x C-f= is, go up to the Terminology section):

#+begin_example
C-x C-f ~/.emacs.d/init.el 
#+end_example
   
    Open your browser and go to this URL:
    Copy the text at that URL. 

    Go back to Emacs and paste that text in. 
    (If you did the tutorial, you know how to paste, but otherwise just use the toolbar paste button or the  and paste it and and type exactly what follows:
    
    Now type:
#+begin_example
C-x C-s
#+end_example
* Learning and Documentation
  The Emacs help system is the best help system of any application ever.
** Emacs tutorial: =C-h t=
   I hope you already did this at this point.
   If you didn't, remember that you can enter the tutorial on the command line by running =emacs -f help-with-tutorial=, 
   or inside Emacs by pressing =C-h t=.

   The Emacs tutorial is quite a bit more helpful than the built-in tutorial of a certain lesser editor.
   The Emacs tutorial is much more comprehensive,
   and it is automatically adjusted to your currently active configuration.
   So, even if you are using cua-mode or evil-mode, the Emacs tutorial is still very helpful, since it tells you when certain keybindings don't work.
   (Of course, you could also leave those modes temporarily, 
   with =M-x cua-mode= or =M-x evil-local-mode=, respectively, 
   and then all the default keybindings will work.)
** describe-*
   Pressing =C-h= then another key will activate various parts of the help system.
   In particular, many of these bindings will activate "describe" commands, which... describe things.
   Of course, these can also be run with =M-x describe-whatever=.
   For example, =M-x describe-key=.
   Below is a small selection of some useful describe keybindings.
   (Links shown by describe commands are underlined, and can be followed by clicking on the link, or by moving point to the link and pressing Enter)

*** =C-h k=
    Runs =describe-key=.
    Prompts for you to press some keybinding.
    Press any keybinding to see 
    - the function it is bound to,
    - other keybindings bound to the same function,
    - the documentation for that function,
    - and a link to the (editable[fn:editable]) source code implementing the function.

    Note that a keybinding in Emacs is simply a mapping from a sequence of one or more keys,
    to some named function (as in "function call") written in the programming language underlying Emacs.
*** =C-h c=
    Runs =describe-key-briefly=.
    Prompts for you to press some keybinding.
    Press any keybinding to see 
    - the function it is bound to,
    displayed briefly in the minibuffer.
*** =C-h m=
    Runs =describe-mode=.
    This will show the documentation for all modes enabled in the current buffer, 
    indexed by a list of links at the top.
    The major mode comes first, then the minor modes in alphabetical order.
    The names of functions are links which will run =describe-function=.
*** =C-h b=
    Runs =describe-bindings=.
    This will show a full list of active bindings,
    marked either 
    - as key translations (see the manual, not relevant to most people),
    - as global bindings, 
    - or by the mode creating those bindings.
    The names of functions are links which will run =describe-function=.
    You should generally prefer =C-h m= as it actually contains documentation,
    but it doesn't list literally all bindings, and this does.
*** =C-h f=
    Runs =describe-function=.
    Prompts for you to type in the name of a Lisp function (such as =describe-function=). 
    Defaults to the function name at point, if point is on the name of a function.
    Then shows 
    - any keybindings bound to that function,
    - the documentation for that function,
    - and a link to the (editable[fn:editable]) source code implementing the function.
    Quite useful while writing Elisp to configure Emacs.
*** =C-h v=
    Runs =describe-variable=.
    Prompts for you to type in the name of a Lisp variable (such as =package-archives=). 
    Defaults to the variable name at point, if point is on the name of a variable.
    Then shows 
    - the current value for that variable,
    - the original value for that variable, if different,
    - the documentation for that variable,
    - a link to the (editable[fn:editable]) source code initially defining the variable,
    - and a link to the Customization interface for that variable, if one exists.
    Quite useful while writing Elisp to configure Emacs.
*** =C-h K=, =C-h F=
    Try =C-h K C-h K= and =C-h K C-h F= 
    (note that "K" and "F" are upper-case, so to enter them you press shift as normal).
    then move on to the next section. :)
** Acesssing the Emacs Manual
   The Emacs manual is, unsurprisingly, very good.
   And, conveniently, it's all available from inside Emacs, in "info" format!
   The info format is a superior alternative to "man" pages;
   it's a form of hypertext that predates, and significantly influenced, HTML.
   You can read any info pages on your system from inside Emacs. 
   (You can also read manpages with =M-x man= or =M-x woman=)
   Sadly, info usage is rare these days. 
   I blame close-minded =vi= users.
   
   In fact, there are separate useful manuals for a number of different components of Emacs,
   all categorized in the "Emacs" section in the info interface.

*** Open Info: =C-h i= or =M-x info=
    This will send you to the =*info*= buffer, in the =info-mode= major mode,
    which defaults to showing the info "directory node", which lists all the info manuals present on your system, categorized by section.
    You can go to the Emacs manual by scrolling down and clicking on it,
    or moving point over the "Emacs" link and pressing Enter.

    You can also use =C-h r= to go directly to the Emacs manual.

    Note that the letter keys, which normally just insert text, are bound to various other useful commands in =info-mode=.
    Likewise =SPC= and =DEL= now go forward and backward through the current manual, one screenful at a time.
    (Since =info-mode= is for reading info, not editing it.)

    To learn about how to quickly and efficient navigate =*info*=,
    press =h= while inside =*info*=, or type =M-x Info-help= from anywhere.
    Or, to get a quick overview, you might just want to use =C-h m= while in =*info*=.
*** =C-h K=
    This key, which you used before, goes to the section of the manual for the entered keybinding.
    It's helpful to find other similar keybindings and commands.
*** Exercise: Navigate to the Help section of the Emacs manual
    Solution: =C-h K C-h C-h=
    
    (That is, use =C-h K= to open the manual section about the following keybinding =C-h C-h=)

    This isn't really an exercise. This is just a great section of the manual. I like it a lot. You should read it.
*** Greatest hits
    Some manuals that are full of cool stuff!

    - Emacs
    - Emacs FAQ
    - Elisp
    - Eshell
*** Note for Debian users
    Debian considers the Emacs manual to be non-free, so it's packaged separately from Emacs.
    You can install the Emacs manual by enabling the non-free repository and installing the package =emacs24-common-non-dfsg=.
    Yes, this is extremely ironic, considering who developed Emacs...
** Figure out WTF just happened
   Lossage is a useful feature (explained here by a quote from the Help section of the manual):
#+begin_quote
If something surprising happens, and you are not sure what you typed,
use ‘C-h l’ (‘view-lossage’).  ‘C-h l’ displays your last 300 input
keystrokes.  If you see commands that you don’t know, you can use ‘C-h
c’ to find out what they do.
#+end_quote
   
   But you can do one better! Try hitting =C-x C-k l= instead! (And navigate to the end)
** GUI features
   The menus are pretty handy. 
   They change with what modes are active, providing access to useful functionality for the current mode.
   Use them!
   Even experienced Emacs users make use of them when exploring new modes and functionality.

   If you're not in GUI mode, you can use =M-x menu-bar-open= or =<F10>= (in Emacs 24.4 or with the init.el I provide) to open the menu bar.
   Note that =<F10>= might be intercepted by your terminal,
   but if you turn off the menu bar in, for example, GNOME Terminal, you can still use it.
   
   Likewise, the tool bar (with buttons on it) sometimes is useful as it sometimes changes with the mode.

   And there are tool-tips when you hover the mouse over the modeline or other buttons.
** Useful online resources
*** See cool features
   - [[http://emacsrocks.com/][Emacs Rocks]]
   - [[http://www.masteringemacs.org/reading-guide/][Mastering Emacs]]
*** Get questions answered
   - Ask me, I'm happy to help, just send me poorly-formatted email
   - CMU Computer Club (the President of the club knows a *lot* about Emacs)
   - [[http://webchat.freenode.net?channels%3D%2523emacs][#emacs on Freenode]]
   - [[https://emacs.stackexchange.com][Emacs Stack Exchange]]
   - Google
* TODO Obligatory rehash of things covered by the tutorial
  These are all covered by the tutorial.
  But they're important, and I don't really trust you to read the tutorial...
  And the concepts are useful to read about twice.

** TODO Cutting and pasting 
   Known in emacs as killing and yanking.
   There is also the "kill ring".
   This is covered by the Emacs tutorial.
   
   =yank-pop=
   
   Important: Explain the ideas of killing.
** Repeating commands multiple times (universal argument)
   =C-u= for positive argument.
   =C--= for negative argument.
   
   Alternatively, =M-1=, =M-2=, ..., =M-0=, =M--= to enter specific counts.

   One example use is for navigating around window splits quickly when you have a number of windows open:
   Just do =M-3 C-x o=.
   
   You may also be looking for macros.
* TODO Basic concepts/features to know
  These are important concepts and features to know about, because otherwise you would probably use a much less efficient way.
  As always, use the manual to learn more.

** TODO Compiling and reacting to errors from Emacs
   Maybe a programming workflow? If python, show M-x run-python. If C, show M-x compile.

   Maybe even basic customization, adding a keybinding for M-x recompile?
*** TODO M-g M-n/p
    Oh, better yet, M-g n/p!
** Find and replace
   =M-x query-replace= takes two strings and, for each occurrence of the first string in the buffer, prompts the user whether to replace it with the second string.
   It's bound to =M-%= by default.

   =M-x query-replace-regexp= does the same thing, just with a regexp instead of the first string.
   It's bound to =C-M-%= by default.

   There is a large amount of find and replace functionality;
   read the "Search" section of the manual.
*** TODO editable occur
    =M-x occur=,
    =M-x occur-edit-mode=
    
** TODO undo and redo with undo-tree
   The tutorial doesn't mention how to redo.
   I guess I should mention it, and also undo-tree-visualize.
** Moving around quickly with search
   Of course, there are many commands for specific movements over text, large and small, and you can read about them in the manual. 
   But one very Emacsy way of getting around is by using the incremental search functionality.
   Just start searching (with =C-s=) for a part of the line/section you want to go to,
   and you can get to it quite fast and naturally.

   1. Press =C-s= (or =C-r=, doesn't matter)
   2. Type a part of the thing you are trying to move point to. Don't press Enter.
   3. Press =C-s= and =C-r= to move between matches until you get where you want to go.
   4. Possibly type more between presses, to narrow down the matches.
      
   Note that incremental search treats case intelligently.
   It will be case-insensitive if you have only lower-case letters in your search string,
   but if you include an upper-case letter it becomes case-sensitive.
** TODO Mark and point and region
   Emacs has an interestingly flexible way to specify regions of text.
   There is a position in the buffer called "mark" which is moved around by certain actions (like searching),
   or set manually with C-SPC.
   Highlighting text is really just highlighting the region between mark and point.
   More than just highlighting, selenicely flexible  
** TODO Macros
   recording
   editing macros
** =M-x dired=
   Emacs is not just capable of opening files, but also opening directories.
   Use =C-x d= or =M-x dired= to open a directory in =dired=.
   
   =dired= has quite a lot of features for manipulating the contents of directories.
   You don't necessarily need to learn them;
   =dired= is an important concept mainly because Emacs sometimes wants to show you a directory,
   and it will show you that directory in =dired=.
   Nevertheless, as usual, the help and manual are good.
** Editing files remotely over SSH and other protocols
   Emacs has a subsystem called TRAMP, which stands for "Transparent Remote Access, Multiple Protocols".
   Generally, you don't directly use TRAMP; it gets used as a side effect of other actions.
   TRAMP allows you to use your local, graphical editor to edit files that are located on a remote, ssh-only server.

   For example, to edit files on the remote host "unix.andrew.cmu.edu" with the username "sbaugh",
   I could do
   =C-x C-f /ssh:sbaugh@unix.andrew.cmu.edu: RET=
   which would log in, possibly prompt for my password, and open a =dired= buffer showing files in my remote home directory.
   I can use =C-x C-f= as normal from there.
   Likewise, I can use =M-x shell= or =M-x eshell= to get a remote shell.
   
   Of course, the abbreviations located in your =~/.ssh/config= still work.
   So what I would actually do is =C-x C-f /ssh:andrew: RET=.
   This makes it simpler to type that prefix from other buffers;
   I can be editing a local file, and do =C-x C-f /ssh:andrew:whatever.txt RET= to access a relevant remote file located in my home directory.
   
   The integration of TRAMP is very deep,
   so nearly everything in Emacs can be done transparently over the network.
* TODO Miscellaneous handy features
** run a single shell command
** quoted-insert
   To insert a literal character, use =C-q=.
** TeX input method
   This is just kind of cool.
** auto-insert-mode
** run shells/eshell from emacs
* Configuration
  Lesser programs are configured by clicking settings in a box, setting flags in some key-value store.
  If you're really lucky, they might store their configuration data in some editable plain text format, like INI or JSON.

  Not so, for Emacs.
  Emacs knows the truth of Lisp: code is data.

#+begin_verse
    When old age shall this generation waste,
    Thou shalt remain, in midst of other woe
    Than ours, a friend to man, to whom thou say'st,
    "Code is data, data code,—that is all
    Ye know on earth, and all ye need to know."
    -- Excerpt from Keats, "Code on a Grecian Urn" (about Lisp)
#+end_verse
  
  Emacs is configured in the same programming language it is written in: Lisp.
  Specifically, Emacs is written in "Emacs Lisp", also called "Elisp", one of the many variants of Lisp.
  Lisp is a functional programming language that has had an immense influence on the history of computing.

  All variables inside Emacs can be freely customized and manipulated by the end-user.
  Many are exposed specifically for the purpose of configuration.
  These are literal variables that are checked or otherwise used by various internal or external functions.
  The mapping of keychords to functions? Just another variable (a list, in fact).
  These are like settings in other editors, but are, obviously, substantially more flexible.

  So how does one manipulate these variables, and, in general, change the behavior of Emacs?
  There are two options,
  both of which can generate Emacs Lisp that your Emacs runs at startup,
  which permanently changes the nature of your Emacs.

** =M-x customize=
  There is an "easy" interactive interface for configuration known as =customize=.
  It can be accessed through =M-x customize=.
  It lists, in a friendly interactive way, all the variables that have been registered and documented as "customizable".
  And, of course, it allows you to set those variables in a straightforward way,
  and persist your changes so that they take effect both in your current Emacs session and all future sessions.
  This is a nice way to leisurely explore what settings are available, though it can become overwhelming.
  
  Keep in mind that =M-x customize= is not in any way weaker than writing Emacs Lisp directly.
  If you direct =M-x customize= to persist your changes,
  it in fact just generates and inserts code into a special section of your =init.el=,
  which is run when Emacs starts.
  You'll read more about =init.el= in the next section.
** =C-x C-f ~/.emacs.d/init.el=
  The other option for manipulating the functionality of Emacs is writing Emacs Lisp code.
  Emacs will automatically run any Elisp it finds in =~/.emacs.d/init.el= on startup.
  It will also run =~/.emacs= if it is present, but =init.el= is preferred these days. 
  The =.d= in =.emacs.d= is for directory; appending a =.d= to the name of a directory is a common practice in Unix.
  
  Most people just set variables in their =init.el=,
  but Elisp is a full-fledged, general-purpose programming language, like Lisp in general.
  The Elisp in your =init.el= can of course load other files containing Elisp and execute them in turn;
  entire elaborate programs can be constructed for Emacs to run on startup.
  If you take a look at the example =init.el= I provided you in the "Getting Started" section,
  you'll see that I made good use of the general-purpose nature of Elisp.
  To bootstrap your Emacs setup,
  I defined a list of quality Emacs Lisp packages available on the internet,
  and looped through it,
  checking whether each package was installed and installing it if it was not.
  A trivial task in a general-purpose language like Elisp,
  but very difficult or impossible for other applications.
  
  You'll learn more about programming in Elisp in the "Programming in Elisp" section.
** Emacs packages/plugins/extensions
   There's actually three options for configuring Emacs;
   the last one just isn't generally thought of as configuration.
   You can install Emacs Lisp packages that other people have made.
   
   If you do =M-x list-packages=, you can see the list of available packages.
   Your Emacs might hang for a moment as it downloads package metadata from the internet;
   to avoid that hang you could use =M-x package-list-packages-no-fetch=.
   The list is drawn from the repositories configured in the =package-archives= variable.
   As usual, you can press =C-h m= to get major-mode documentation.
   
   There are lots of exciting packages here!
   But show some restraint, don't just install them all.
   
   When you install a package, it is downloaded to =~/.emacs.d/elpa=,
   and Emacs scans the package for code marked "autoload".
   Code marked "autoload" will be automatically loaded when Emacs starts;
   generally, just a few stub functions are autoloaded, 
   and those functions chain-load the rest of the package when they are actually run by the user.
   This is called "lazy loading"; it speeds startup time and reduces memory usage.
   (Core Emacs is also lazy loaded.)
   
   Packages might be confused with "plugins" or "extensions" in lesser applications.
   But packages are the core building block of Emacs;
   since Emacs is programmed largely in Emacs Lisp,
   most of its functionality is already divided into packages using the same format and interfaces of user packages.
   So a package is really no different from any other component of Emacs.
   You can see the core Emacs package in =M-x list-packages=, marked "built-in".
** Starter kits
   OK, maybe there's actually four options for configuring Emacs.
   There are lots of starter kits out there that you can download,
   which will do a lot of configuration for you,
   and install a bunch of exciting Emacs Lisp packages all at once.
   They are basically no different from the =init.el= that I provided you,
   just much larger in scale.

   Starter kits are generally seen as a [[https://github.com/technomancy/emacs-starter-kit][very bad idea]].
  
   However, after today's workshop, and by consulting my notes, 
   I think you will know enough about Emacs to decide on your own whether to use a starter kit.
   As long as you read that "very bad idea" link just above.
   Note that the =init.el= that is provided alongside these notes is optimized to be both
    - very short and understandable
    - everything you need
   In fact the =init.el= that I provided you is quite close to the one I actually use.
   So I question whether more configuration is actually necessary...
   But, if you want, you can try out some starter kits.
   So here is a list of the "popular" ones:

   - [[https://github.com/bbatsov/prelude][Prelude]] ("an Emacs distribution that aims to enhance the default Emacs experience")
   - [[https://github.com/overtone/emacs-live][Emacs Live]] (Designed for live art/music coding with Clojure; the only one that I would actually consider using)
   - [[https://github.com/syl20bnr/spacemacs/][Spacemacs]] (Uses the independently developed =evil-mode= package which emulates vim, then adds a lot more stuff on top
     Has a pretty stupid [[https://en.wikipedia.org/wiki/Not_invented_here][NIH]] configuration system)
* Useful popular Emacs packages
  Before we get into actual programming, let's look at some useful packages that already exist,
  available from the popular Emacs package repositories.
  Here are the repos I use, which are also configured in the provided =init.el=.
#+begin_src emacs-lisp
(setq package-archives
      '(;; GNU ELPA, the default package archive, with GNU packages
	("gnu" . "http://elpa.gnu.org/packages/")
	;; Marmalade, a real repository with many released packages
	("marmalade" . "http://marmalade-repo.org/packages/")
	;; MELPA, unstable packages scraped straight off of Github
        ("melpa" . "http://melpa.milkbox.net/packages/")))
#+end_src

** TODO ix
   Pasting to ix.io

   Would be nice if I could get scpaste working...

   Configure scpaste to paste to ~/www, then generate cmu.io/~andrewid/ link!
   That could be awesome!
   Too bad scpaste is broken and the link gets flushed out of the minibuffer instantly...
** magit
   Available in Marmalade or MELPA.

   Probably the best git interface in existence, makes things convenient without abstraction.
   Allows you to use Emacs and git together in some really super-powered ways. 
   Try =M-x magit-blame=!
** AUCTeX
   Available in Marmalade or MELPA.
   
   Pretty awesome environment for writing LaTeX.
   Includes inline previews!
** undo-tree
   Preinstalled by the =init.el= I distributed.
   Available in ELPA.
   
   This provides a nicer interface to the default Emacs undo system.
   (By default, you only have "undo", and you're supposed to redo by... undoing your previous undos.)
   The =init.el= I gave you turns it on globally.
** calc
   Comes with Emacs.

   A... calculator? Inside Emacs? Why would I ever need thi-OH MY GOD IT CAN READ IN LATEX AND SOLVE LATEX EQUATIONS AND SPIT OUT LATEX OUTPUT THIS IS AMAZING.
 
   It has a manual and tutorial which are pretty nice, check it out.
** org-mode
   Comes with Emacs.

   A useful note-taking, planning, time-tracking, organizing, publishing mode. 

   It is legendary and acclaimed by many, but a bit of a behemoth...
   I haven't yet gotten into it that much.
   
   Check out the org-mode manual to learn more.
** evil-mode
   Available in third-party repos.
   
   Adds a bunch of keybindings to pretty fully emulate vim.
   I use this myself.
   With this package, Emacs is a better vim than vim is.
** Games
   A number of games come with Emacs.

   Look at the Games section of the Emacs manual for a full list.
*** =M-x tetris=
*** =M-x snake=
*** =M-x gomoku=
*** =M-x dunnet=
* Programming in Elisp
** Lisp basics
   http://learnxinyminutes.com/docs/elisp/
   (I really like that site)
   
   More in depth stuff:
   https://github.com/chrisdone/elisp-guide
   
   If you really want to learn Lisp, go for the classic, mighty, wizardly book:
   SICP
   http://mitpress.mit.edu/sicp/
   (It's very famous)
** write a time-tracking extension (workshop)
   Use quantified self extension as an example of the ease of configuration
* Other non-Emacs best practices
** keyboard based workflow
   Basically anything that enables a keyboard based workflow.
   By not moving your hands to the mouse or even to Home/End/etc, you can type and edit faster.
   Just make sure you know how to touch type.
** Semantic Linefeeds!
   One sentence (or clause) per line.
   Pretty much every kind of structured text will just ignore single newlines (LaTeX, Markdown).
   So, when using an editor that has a lot of tools for manipulating lines (pretty much everything), 
   you gain a lot of power with this organization!
   http://rhodesmill.org/brandon/2012/one-sentence-per-line/
** tools with emacs-nature
*** browser
    - conkeror
    - keysnail
*** shell
    Readline already has Emacs keybindings by default.
    C-x C-e in bash by default drops you into your $EDITOR, which is hopefully some variation of emacsclient
*** file manager
    Dired is already quite okay.
*** editing elsewhere
    OS X has some fancy thing where you can have emacs keybindings in every text editing field.
* TODO Philosophy
  I need to move this out of this file...
** Terminals suck
   Terminals suck, vim and emacs are both crippled by what they have to do to support running in a terminal.
   But Emacs is substantially *less* crippled. :)
** Anti-configuration
   Why should you need to configure things just to fix broken defaults?
   If a configuration is nearly universally agreed to be good, *it should be the default*.
** Plan 9, Unix
   People say Emacs is counter to the Unix philosophy.
   Nothing could be further from the truth.
   Consider the epitome of the Unix philosophy: the Plan 9 operating system.
   Plan 9 was a text-driven system, with powerful primitives for composing programs.
   And what was the primary interface to this operating system?
   The editor, acme!
   The best interface to a system that is primarily composed of text,
   is the text editor,
   both in Plan 9 and in Unix.
   (Unfortunately, acme is not portable to non-Plan 9 systems.)
   
   All but one of your applications can be non-interactive, 
   simply taking in text and spitting it back out, 
   possibly with some side effects.
   Then, orchestrating and controlling the other programs,
   conducting this dance of development,
   is the text editor.
   If everything is communicating with text,
   then the natural place for you to do interactive things is inside the text editor.
** The mouse is not evil
   Frequently it is suggested that the mouse is evil and you should avoid it 5ever!!
** Terminals suck - so how to replace them?
   Don't just make a "modern terminal" with fancy features.
   You'll just need to support all the old crap of historical terminals.
   You can *so easily* escape the terminal: just run shells inside Emacs.
   But, even if you don't like that, you don't need to make a terminal to get a new version of the command line.
   Jettison all those awful interactive programs, and you will be free;
   you can write whatever you want without terminal compatibility.
   Yes, this includes tmux.

   Programs should not need terminfo. 
   That is a harmful mixing of concerns.
   Formatting on the screen should be dealt with at the formatting-on-the-screen level.
   Really ideally the replacement would be fucking Atom... too bad it's slow as SHIT.

** vim sucks lmao
   UI primitives, 
   system integration, 
   and a few hot-spot functions that need maximum efficiency.
   The rest is all Elisp that can be modified by the user at will.

   Emacs is capalbe of asynchronous operations,
   and easily integrates external programs.
   I use the Emacs gdb interface all the time, 
   and if I want to grep my project, it'll show up incrementally in a buffer without blocking the UI or stopping me from editing. 
   
   Vim on the other hand... well... it has its own built-in C reimplementation of spell-checking and encryption.
   Emacs just uses aspell and PGP.
   And we all know the troubles vim has with asynchronicity and integrating external programs.

* Footnotes

[fn:whyiswitched]
  This is actually why I switched to Emacs myself initially.
  I used to be a master user of vim, and I ran into this problem all the time.
  It was so annoying!
  I tried out Emacs and instantly this problem was solved, along with many other problems I had forgotten I even had.
  I never looked back. (except to pity those who haven't yet switched)

[fn:editable] 
  Of course you would need to re-evaluate the file
  to change the definition of the functions and variables contained within.
  But you can indeed do that trivially at run-time... 
  though I won't say how, in this footnote, since you might mess things up!!!
